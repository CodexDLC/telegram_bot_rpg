# Логика системы: Reactive Burst Combat (RBC) — Monolith Implementation

Эта спецификация описывает реализацию реактивного боя внутри монолита с использованием `asyncio` задач для фонового «Актера-надсмотщика».

## 1. Структура ключей в Redis (Single Source of Truth)

Все данные боя хранятся в Redis. Это обеспечивает атомарность и доступность для всех компонентов.

| Ключ | Тип | Описание |
| :--- | :--- | :--- |
| `combat:{id}:meta` | Hash | Глобальные данные: `status` (active/finished), `type`, `start_time`. |
| `combat:{id}:actors` | Hash | Поле: `char_id`. Значение: JSON `FighterStateDTO`. Хранит HP, ману, статы и `afk_level`. |
| `combat:{id}:exchanges:{char_id}` | List | Очередь ID противников, с которыми игроку предстоит обменяться ударами. |
| `combat:{id}:moves:{char_id}` | List | Очередь «патронов» (заявленных ходов). Каждый элемент — JSON `CombatMoveDTO`. |
| `combat:{id}:sync` | Hash | Таблица прицелов (Match Map). Поле: `char_id`. Значение: `target_id` (в кого сейчас целится игрок). |

## 2. Структуры данных (DTO)

### FighterStateDTO
Хранится в `combat:{id}:actors`. Содержит состояние бойца и метрики AFK.
```python
{
    "char_id": "player_1",
    "hp": 100,
    "energy": 50,
    "afk_level": 0,           # Счетчик пропущенных (форсированных) ходов
    "penalty_timer": 60,      # Текущий лимит времени на ход (60 -> 50 -> ... -> 30)
    "stats": {...},           # Сила, ловкость и т.д.
    "effects": [...]          # Активные баффы/дебаффы
}
```

### CombatMoveDTO
Хранится в `combat:{id}:moves:{char_id}`. Представляет собой заявку на действие.
```python
{
    "target_id": "enemy_1",
    "attack_zones": ["head", "chest"],
    "block_zones": ["legs", "feet"],
    "skill_id": "heavy_strike",
    "execute_at": 1700000060  # Timestamp (Unix), когда Актер пробьет ход принудительно
}
```

## 3. Разделение обязанностей

### А. Оркестратор Боя (Game Core API)
Публичные методы, которые вызывает Бот (клиент) или Актер.

1.  **`start_battle(players, enemies)`**:
    *   Создает все ключи в Redis (`meta`, `actors`).
    *   Формирует списки очередей противников в `exchanges:{char_id}`.
    *   Запускает фонового Актера: `asyncio.create_task(battle_supervisor(id))`.

2.  **`get_next_target(char_id)`**:
    *   Смотрит в `exchanges:{char_id}`.
    *   Возвращает данные первого врага из `actors` или сигнал «Жди», если список пуст.

3.  **`register_move(char_id, target_id, move_data)`**:
    *   Получает текущий `penalty_timer` из DTO игрока.
    *   Вычисляет `execute_at = time.now() + penalty_timer`.
    *   Пишет ход в хвост списка `moves:{char_id}`.
    *   Ставит метку в `sync`: `sync[char_id] = target_id`.

4.  **`process_exchange(id_a, id_b, is_forced=False)`**:
    *   *Вызывается разовой таской, которую инициировал Актер.*
    *   **Логика AFK:**
        *   Если `is_forced=True` (таймаут): Инкрементирует `afk_level`, снижает `penalty_timer` (минимум до 30 сек).
        *   Если ход живой (`is_forced=False`): Сбрасывает `afk_level` в 0, возвращает `penalty_timer` к 60 сек.
    *   Считает урон, применяет эффекты, обновляет `actors`.
    *   Удаляет обработанные ходы из `moves`.
    *   Чистит `sync` для этих игроков.
    *   Обновляет очереди `exchanges` (удаляет текущего врага, если он повержен или обмен завершен).

### Б. Актер (Background Supervisor)
Легкая фоновая задача (`asyncio.Task`) с адаптивным `sleep`. Работает в том же процессе, что и Core.

**Цикл работы:**
1.  **Поиск пар (Matchmaking):**
    *   Ищет в `sync` взаимные пары: `sync[A] == B` И `sync[B] == A`.
    *   Если нашел — запускает `asyncio.create_task(process_exchange(A, B, is_forced=False))`.
    *   Сбрасывает `sleep` до 0.1 сек.

2.  **Принудительное продвижение (Force Push):**
    *   Если пар нет, проверяет головы списков `moves` (LINDEX 0).
    *   Сравнивает `execute_at` с текущим временем.
    *   Если время вышло — запускает `asyncio.create_task(process_exchange(A, Target, is_forced=True))`.

3.  **Адаптивный Sleep:**
    *   Если действий нет — `sleep` постепенно растет (0.1 -> 0.5 -> 1.0), чтобы не грузить CPU в простое.

### В. Бот (UI Client)
Временная прослойка, напрямую вызывающая методы Core.

*   **Действие:** При нажатии кнопки вызывает `register_move`.
*   **Отображение:** Сразу после регистрации хода вызывает `get_next_target` и перерисовывает экран под следующего врага в очереди (Optimistic UI), не дожидаясь результата расчета предыдущего удара.

## 4. Логика Агрессивного AFK

Система наказывает за бездействие ускорением таймеров.

*   **Норма:** Игрок имеет 60 секунд на ход.
*   **Наказание:** Если Актер сработал по таймауту (`is_forced=True`):
    *   `afk_level += 1`
    *   `penalty_timer = max(30, 60 - (afk_level * 10))`
    *   *Эффект:* Следующий ход, который зарегистрирует игрок (или который уже лежит в очереди), получит `execute_at` уже не через 60, а через 50, 40 или 30 секунд. Бой для "тугодума" ускоряется принудительно.
*   **Амнистия:** Если игрок сам прислал ход вовремя, `afk_level` обнуляется, таймер возвращается к 60 сек.

## 5. Преимущества реализации в монолите
1.  **Скорость:** Нет HTTP-запросов между Актером и Оркестратором. Всё — вызовы функций в одной памяти.
2.  **Атомарность:** `asyncio` работает в одном потоке (Event Loop), поэтому таска расчета (`process_exchange`) гарантированно обновит Redis до того, как следующая итерация Актера найдет ту же пару. Race conditions минимизированы.
3.  **Масштабируемость:** Можно держать сотни таких `asyncio.task` (Актеров) в одном процессе без блокировки основного потока.
