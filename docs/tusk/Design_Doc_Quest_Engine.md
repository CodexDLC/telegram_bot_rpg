# Design Document: RPG Quest Scenario Engine (v1.0)

## 1. Общее описание системы
Система **ScenarioEngine** предназначена для запуска изолированных текстовых сценариев (квестов) с поддержкой процедурной генерации, динамической сложности и адаптации контента под текущие характеристики (билд) персонажа.
Главная цель — создать "реактивный" мир, где каждое действие игрока меняет не только его параметры, но и доступные в будущем сюжетные пути.

---

## 2. Архитектура данных

### 2.1. Постоянное хранилище (БД PostgreSQL)

#### Таблица A: `quest_master` (Scenario_Master)
Глобальные настройки квеста.

| Поле | Описание |
| :--- | :--- |
| **quest_key** (PK) | Уникальный ID квеста (напр. `awakening_rift`). |
| **start_node_id** | ID начальной точки. |
| **init_sync** | **(Импорт)**: Список команд для наполнения «песочницы» при старте квеста. |
| **export_sync** | **(Экспорт)**: Список команд для возврата данных в реальный мир при завершении квеста. |
| **status_bar_fields** | JSON-список названий полей (например, `["Золото", "Здоровье"]`) и соответствующих им ключей в дампе. |
| **config** | JSON: Дополнительные настройки, не вошедшие в другие поля. |

#### Таблица B: `quest_nodes` (Scenario_Nodes)
Контентная база. Каждая запись — это отдельная сцена.

| Поле | Описание |
| :--- | :--- |
| **node_key** (PK) | Уникальный ID шага внутри квеста. |
| **quest_key** (FK) | Привязка к мастеру. |
| **text_content** | Художественный текст с поддержкой плейсхолдеров (`[#stat:str]`). |
| **selection_requirements** | JSON: Фильтр на вход (Smart Selection). Условия, при которых эта нода может быть выбрана. |
| **actions_logic** | JSON: Логика кнопок, математика изменений и переходы (Edges). |

#### Таблица C: `character_quest_state`
Таблица резервного копирования ("Сейв"). Хранит полный снимок сессии для восстановления.

| Поле | Тип | Описание |
| :--- | :--- | :--- |
| **char_id** (PK) | `BigInteger` | ID персонажа. |
| **quest_key** (PK) | `String` | ID текущего квеста. |
| **current_node_key** | `String` | ID текущей сцены (где игрок остановился). |
| **context** | `JSONB` | Полный дамп переменных квеста (статы, флаги, токены). Точная копия Redis-дампа. |
| **session_id** | `UUID` | ID сессии (для валидации актуальности). |
| **updated_at** | `Timestamp` | Время последнего сохранения. |

### 2.2. Оперативное хранилище (Redis)

*   **Глобальный аккаунт (`ac:{char_id}`)**:
    *   `state`: Переключается в `scenario` при старте.
    *   `scenario_session_id`: Уникальный ID текущей сессии.
    *   Стандартные поля (HP, Energy, Gold) используются как источник для инициализации.

*   **Сессионный дамп (`scen:session:{char_id}:data`)**:
    *   Изолированная "песочница" для квеста.
    *   Все изменения происходят здесь, не затрагивая основной профиль до момента финализации.
    *   Хранит: `context` (статы квеста), `flags`, `tokens`.

*   **Статичный кэш нод (`scen:static:{quest_key}`)**:
    *   Хэш-таблица всех нод квеста для мгновенного доступа без обращения к БД.

### 2.3. Формат Инструкции Синхронизации (Sync Instruction Format)

Мы вводим стандарт записи для полей `init_sync` и `export_sync`. Каждая строка инструкции состоит из трех частей, разделенных двоеточием:
`METHOD:KEY[:FIELD/PATH]`

1.  **Method**: Какую операцию выполнить (аналог методов в RedisService).
2.  **Key**: Паттерн ключа в Redis (с поддержкой переменных типа `{char_id}`).
3.  **Path/Field**: Опциональный параметр для хешей или вложенных JSON.

**Примеры команд:**
*   `hjson:ac:{char_id}:stats.strength` — Вызвать `get_hash_json`, поле `stats`, достать `strength`.
*   `val:player:status:{char_id}` — Вызвать `get_value` для обычной строки.
*   `lpop:rewards:queue:{char_id}` — Вызвать `pop_from_list_left`.
*   `set:achievements:{char_id}:first_blood` — Проверить `is_set_member`.

---

## 3. Ключевые механизмы логики

### 3.1. Smart Selection (Умный выбор ноды)
При каждом переходе система выполняет фильтрацию потенциальных целевых нод:
1.  **Пул кандидатов**: Список нод, подходящих по смыслу или тегу.
2.  **Валидация**: Каждая нода проверяется через выражение в `selection_requirements` (например, `stats.strength > 15`).
3.  **Приоритезация**: Если условий несколько, выбирается наиболее специфичное или случайное из подходящих. Это позволяет подстраивать сюжет под билд игрока.

### 3.2. Трехуровневая логика действий
1.  **Уровень 1: Conditions**: Проверка доступности самой кнопки (например, "Вскрыть замок" видна только при наличии отмычки).
2.  **Уровень 2: Math**: Применение математических эффектов к дампу сессии (поддержка операторов `+`, `-`, `=` и кубиков типа `1d5`).
3.  **Уровень 3: Branching**: Определение финальной целевой ноды после применения математики (например, проверка на смерть игрока или успех действия).

---

## 4. Пайплайн выполнения (Runtime Pipeline)

Вся бизнес-логика инкапсулирована в методы `ScenarioCoreOrchestrator`.

### 1. `initialize_scenario` (Запуск)
*   Проверяет/заполняет статичный кэш нод в Redis.
*   Создает сессионный дамп `scen:session:{char_id}:data`.
*   Копирует данные из `ac:{char_id}` в дамп по инструкции (`init_sync`), используя формат `METHOD:KEY`.
*   Устанавливает статус через `ScenarioManager` (записывает `scenario:{session_id}`).
*   Первая запись в `character_quest_state` (БД).

### 2. `step_scenario` (Ход)
*   **Input**: Принимает `action_payload` от игрока.
*   **Process**:
    *   Применяет математику к дампу сессии (например, вычитает золото).
    *   Выбирает следующую ноду (Smart Selection).
    *   Асинхронно обновляет `character_quest_state` в БД (каждые N шагов).
*   **Output**: Собирает DTO для бота (Текст, Статус-бар, Кнопки).

### 3. `resume_scenario` (Восстановление)
*   Вызывается, если `ac.state == "scenario"`, но данных в Redis нет (TTL истек).
*   Загружает `context` и `current_node_key` из таблицы `character_quest_state`.
*   Восстанавливает сессию в Redis (`scen:session:{char_id}:data`).
*   Возвращает текущий шаг (аналогично `step_scenario`).

### 4. `finalize_scenario` (Выход)
*   Выполняет экспорт измененных данных из дампа обратно в `ac:{char_id}` (согласно `export_sync`), используя формат `METHOD:KEY`.
*   Удаляет сессионные ключи и сбрасывает статус игрока.
*   Переводит `ac.state` обратно в `world`.

---

## 5. Техническая реализация (Code Structure)

### ScenarioCoreOrchestrator
Универсальный класс для управления сценарием. Реализует методы `initialize`, `step`, `resume`, `finalize`.
*   **ScenarioManager**: Специализированный менеджер для работы с Redis-ключами сценария.
*   **Evaluator**: Обертка над `simpleeval` для безопасного вычисления условий и эффектов.
*   **Formatter**: Парсер тегов в тексте.

### Пример Сценария: «Пробуждение» (Awakening)
*   **Этап 1 (Init)**: Создание персонажа, статы 8x8.
*   **Этап 2 (Rift)**: "Умный" инстанс. Выборы меняют статы и начисляют Affinity Tokens. Движок выбирает сцены на основе Affinity.
*   **Этап 3 (Final)**: Выдача Дара (Symbiote) на основе накопленных токенов.
