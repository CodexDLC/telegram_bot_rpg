# ТЕХНИЧЕСКИЙ ДИЗАЙН: UNIFIED ITEM SYSTEM

Цель: Создать гибкую, масштабируемую систему предметов, поддерживающую Лут, Крафт и Экономику.

Принцип: Отказ от JSON в пользу Python-словарей (TypedDict) для скорости и типизации.

Архитектура: Registry (Data) -> Assembler (Logic) -> Service (Flow).

---

## 1. Концепция Генерации

Предмет в игре не является монолитом. Это конструктор.

### Формула Сборки

> **Item = Base + Material (Tier) + Essence (Bundle/Suffix)**

1. **Base (Основа):** Физическая форма предмета (Меч, Нагрудник). Определяет слот, тип атаки/защиты и базовые анимации. Является готовым "мусорным" предметом (Тир 0).
    
2. **Material (Материал):** Определяет **Тир (Редкость)**. Железный меч (Тир 1) слабее Меча Бездны (Тир 5). Материал дает множитель характеристик и запас прочности.
    
3. **Essence (Эссенция/Суффикс):** Магическая добавка. Определяет набор бонусов (Бандл). Например, "Эссенция Вампира" добавляет эффект вампиризма.
    

### Жизненный Цикл (Inventory Pool)

Чтобы не засорять БД миллионами записей:

1. **System Inventory:** Сгенерированные предметы сначала принадлежат Системе (`owner_id='SYSTEM'`).
    
2. **Reuse:** Если системе нужно выдать "Ржавый меч", она сперва ищет свободный меч в своем пуле. Если нашла — чинит и отдает. Если нет — создает новый.
    
3. **Economy:** При продаже/выбросе предмет не удаляется, а возвращается в пул Системы (или разбирается на ресурсы).
    

---

## 2. Архитектура Данных (Data Layer)

Все данные хранятся в пакете apps/game_core/resources/game_data/items/.

Мы используем Python Dictionaries вместо JSON.

### 2.1. Структура Файлов

|**Файл**|**Описание**|**Пример данных**|
|---|---|---|
|`bases.py`|**Болванки (Тир 0).** Готовые предметы "низкого качества". Служат шаблонами для генерации.|`rusty_sword`, `rag_shirt`|
|`materials.py`|**Компоненты Крафта.** Слитки, кожа, ткани. Определяют множители Тиров.|`iron_ingot` (x1.0), `void_ingot` (x5.0)|
|`raw_resources.py`|**Сырье.** То, что добывается в мире (руда, шкуры). Нужно для крафта компонентов.|`iron_ore`, `wolf_pelt`|
|`affix_config.py`|**Магия.** Реестр атомарных эффектов и Бандлов (сетов), привязанных к Эссенциям.|`effect_crit`, `bundle_vampire`|
|`__init__.py`|**Диспетчер (Registry).** Собирает все словари в единый индекс для быстрого поиска.|`get_item_data(id)`, `get_base_by_id(id)`|

---

## 3. Диспетчер (`__init__.py`)

Это "Умный Кладовщик". Он не содержит бизнес-логики (не считает урон, не роллит шансы).

Его задачи:

1. **Агрегация:** При старте бота импортирует все словари (`BASES_DB`, `MATERIALS_DB`...) и собирает их в единый плоский `ITEM_REGISTRY`.
    
2. **Поиск O(1):** Метод `get_item_data(item_id)` мгновенно возвращает данные любого предмета (будь то меч, руда или слиток) для отображения в Инвентаре.
    
3. **Фильтрация:** Предоставляет методы для генераторов:
    
    - `get_material_for_tier('ingots', 5)` — Дай мне металл 5-го уровня.
        
    - `get_random_base('melee_weapon')` — Дай случайное оружие.
        

---

## 4. План Разработки

Мы разбиваем реализацию на четкие этапы. Сейчас мы приступаем к **Этапу 1**.

### ✅ Этап 1: Фундамент Данных (Data Layer)

- **Задача:** Создать структуру файлов и наполнить их тестовыми данными (Скелет).
    
- **Результат:**
    
    1. Создан пакет `items/`.
        
    2. Файл `bases.py` содержит 3-5 примеров (Меч, Топор, Роба).
        
    3. Файл `materials.py` содержит материалы для Тиров 0, 1, 2.
        
    4. Файл `raw_resources.py` содержит базовое сырье.
        
    5. Файл `affix_config.py` содержит пару эффектов.
        
    6. Файл `__init__.py` умеет всё это собирать и отдавать по ID.
        

### ⏳ Этап 2: Логика Сборки (Assembler)

- **Задача:** Написать класс `ItemAssembler`, который умеет математически "склеивать" словари.
    
- **Логика:** `Base['damage'] * Material['mult'] + Bundle['bonus']`.
    
- **Результат:** Метод, возвращающий готовый `dict` предмета с пересчитанными статами и списком тегов.
    

### ⏳ Этап 3: Сервисы Генерации (Service Layer)

- **Задача:** Реализовать `LootService` и `CraftService`.
    
- **Логика:** Шансы выпадения, работа с LLM (генерация описаний), сохранение в БД (Pool System).