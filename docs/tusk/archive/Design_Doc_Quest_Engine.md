# Design Document: RPG Quest Scenario Engine (v2.0)

## 1. Общее описание системы
Система **ScenarioEngine** предназначена для запуска изолированных текстовых сценариев (квестов) с поддержкой процедурной генерации, динамической сложности и адаптации контента под текущие характеристики (билд) персонажа.
Главная цель — создать "реактивный" мир, где каждое действие игрока меняет не только его параметры, но и доступные в будущем сюжетные пути.

---

## 2. Архитектура данных

### 2.1. Постоянное хранилище (БД PostgreSQL)

#### Таблица A: `quest_master` (Scenario_Master)
Глобальные настройки квеста.

| Поле | Описание |
| :--- | :--- |
| **quest_key** (PK) | Уникальный ID квеста (напр. `awakening_rift`). |
| **start_node_id** | ID начальной точки. |
| **status_bar_fields** | JSON-список названий полей (например, `["Золото", "Здоровье"]`) и соответствующих им ключей в дампе. |
| **config** | JSON: Дополнительные настройки. |

#### Таблица B: `quest_nodes` (Scenario_Nodes)
Контентная база. Каждая запись — это отдельная сцена.

| Поле | Описание |
| :--- | :--- |
| **node_key** (PK) | Уникальный ID шага внутри квеста. |
| **quest_key** (FK) | Привязка к мастеру. |
| **text_content** | Художественный текст с поддержкой плейсхолдеров (`[#stat:str]`). |
| **selection_requirements** | JSON: Фильтр на вход (Smart Selection). Условия, при которых эта нода может быть выбрана. |
| **actions_logic** | JSON: Логика кнопок, математика изменений и переходы (Edges). |
| **is_terminal** | Boolean: Флаг завершения квеста. |

#### Таблица C: `character_quest_state`
Таблица резервного копирования ("Сейв"). Хранит полный снимок сессии для восстановления.

| Поле | Тип | Описание |
| :--- | :--- | :--- |
| **char_id** (PK) | `BigInteger` | ID персонажа. |
| **quest_key** (PK) | `String` | ID текущего квеста. |
| **current_node_key** | `String` | ID текущей сцены (где игрок остановился). |
| **context** | `JSONB` | Полный дамп переменных квеста (статы, флаги, токены). Точная копия Redis-дампа. |
| **session_id** | `UUID` | ID сессии (для валидации актуальности). |
| **updated_at** | `Timestamp` | Время последнего сохранения. |

### 2.2. Оперативное хранилище (Redis)

*   **Глобальный аккаунт (`ac:{char_id}`)**:
    *   `state`: Переключается в `scenario` при старте.
    *   `scenario_session_id`: Уникальный ID текущей сессии.
    *   `active_quest_key`: ID текущего квеста.

*   **Сессионный дамп (`scen:session:{char_id}:data`)**:
    *   Изолированная "песочница" для квеста.
    *   Все изменения происходят здесь, не затрагивая основной профиль до момента финализации.
    *   Хранит: `context` (статы квеста), `flags`, `tokens`, `step_counter`.
    *   Поддерживает типы данных: `int`, `float`, `str`, `bool`, `list`, `dict` (через JSON-сериализацию).

*   **Статичный кэш нод (`scen:static:{quest_key}`)**:
    *   Хэш-таблица всех нод квеста для мгновенного доступа без обращения к БД.

---

## 3. Ключевые механизмы логики

### 3.1. Smart Selection (Умный выбор ноды)
При каждом переходе система выполняет фильтрацию потенциальных целевых нод:
1.  **Пул кандидатов**: Список нод, подходящих по смыслу или тегу (через `pool:tag`).
2.  **Валидация**: Каждая нода проверяется через выражение в `selection_requirements` (например, `stats.strength > 15`).
3.  **Приоритезация**: Если условий несколько, выбирается наиболее специфичное (последнее в списке валидных).

### 3.2. Трехуровневая логика действий
1.  **Уровень 1: Conditions**: Проверка доступности самой кнопки (например, "Вскрыть замок" видна только при наличии отмычки).
2.  **Уровень 2: Math**: Применение математических эффектов к дампу сессии (поддержка операторов `+`, `-`, `=` и кубиков типа `1d5`).
3.  **Уровень 3: Branching**: Определение финальной целевой ноды после применения математики (например, проверка на смерть игрока или успех действия).

### 3.3. Logic Gates (Автоматические переходы)
Специальный тип действия `auto` в `actions_logic`.
*   Не требует ввода пользователя.
*   Позволяет строить цепочки проверок (if/else) и перенаправлять игрока.
*   Поддерживает рекурсивный проход (Gate -> Gate -> Node).

---

## 4. Пайплайн выполнения (Runtime Pipeline)

Вся бизнес-логика инкапсулирована в методы `ScenarioCoreOrchestrator`.

### 1. `initialize_scenario` (Запуск)
*   **Input**: `char_id`, `quest_key`.
*   **Process**:
    *   Загружает `quest_master`.
    *   Вызывает специфичный `Handler` (через `handler_registry`) для инициализации контекста (`on_initialize`).
    *   Создает сессию в Redis и регистрирует её в аккаунте.
    *   Делает первичный бэкап в БД.
*   **Output**: DTO первой сцены.

### 2. `step_scenario` (Ход)
*   **Input**: `char_id`, `action_id`.
*   **Process**:
    *   Загружает контекст (Redis -> DB Fallback).
    *   `ScenarioDirector` исполняет логику шага:
        *   Применяет математику действия.
        *   Резолвит ветвление (`branching`).
        *   Обрабатывает `Logic Gates` и пулы (`pool:`).
    *   Обновляет контекст в Redis.
    *   Асинхронно обновляет бэкап в БД (каждые 5 шагов или по флагу `force_backup`).
*   **Output**: DTO новой сцены.

### 3. `resume_scenario` (Восстановление)
*   **Input**: `char_id`.
*   **Process**:
    *   Восстанавливает контекст из Redis или БД.
    *   Повторно формирует DTO для текущей ноды (без выполнения действий).
*   **Output**: DTO текущей сцены.

### 4. `finalize_scenario` (Выход)
*   **Input**: `char_id`.
*   **Process**:
    *   Вызывает специфичный `Handler` для финализации (`on_finalize`).
    *   Хендлер переносит награды (статы, предметы, навыки) в основной профиль.
    *   Очищает сессию в Redis и удаляет бэкап из БД.
    *   Возвращает аккаунт в состояние `world`.
*   **Output**: Статус завершения и целевая локация возврата.

---

## 5. Техническая реализация (Code Structure)

### Core Components
*   **ScenarioCoreOrchestrator**: Фасад для внешних вызовов. Координирует работу компонентов.
*   **ScenarioManager**: Управление данными (Redis + DB Repository). Реализует "умную загрузку" и бэкапы.
*   **ScenarioDirector**: Логика переходов, ветвлений и выборки нод.
*   **ScenarioEvaluator**: Математический движок (SimpleEval). Поддерживает кубики (`1d6`), списки (`push/pop`) и функции (`has_item`).
*   **ScenarioFormatter**: Сборка DTO, парсинг тегов в тексте (`[#stat]`).

### Handlers System
Система расширяемых обработчиков для специфичной логики квестов.
*   **BaseScenarioHandler**: Абстрактный класс.
*   **HandlerRegistry**: Фабрика, возвращающая нужный хендлер по `quest_key`.
*   **TutorialHandler**: Реализация для туториала (`awakening_rift`).

### DTOs
*   **ScenarioResponseDTO**: Обертка ответа.
*   **ScenarioPayloadDTO**: Данные сцены (текст, статус-бар, кнопки).
*   **ScenarioButtonDTO**: Описание кнопки.

---

## 6. Пример JSON структуры (Node)

```json
{
  "node_key": "rift_event_fire_01",
  "quest_key": "awakening_rift",
  "text_content": "Осколок пылает. Путь преграждает огненная стена.",
  "actions_logic": {
    "power": {
      "label": "[СИЛА] Пройти насквозь",
      "to_node": "next_step",
      "math": {
        "w_strength": "+2",
        "t_fire": "+1",
        "hp": "-1d6"
      }
    },
    "auto": {
      "type": "logic_gate",
      "branching": [
        {
          "condition": "w_strength > 10",
          "to_node": "success_node"
        },
        {
          "condition": "default",
          "to_node": "fail_node"
        }
      ]
    }
  }
}
```
