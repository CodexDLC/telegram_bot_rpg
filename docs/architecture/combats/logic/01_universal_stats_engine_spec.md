# Technical Spec: Universal Stats Engine (Waterfall Calculation)

**Тип:** Core Logic / Math Engine
**Роль:** Универсальный калькулятор характеристик, работающий на Text-Based Math Protocol.
**Применение:** Боевая система, Меню персонажа, Проверки в диалогах.

---

## 1. Аксиома Баланса v3.0 (Philosophy)

Мы разделяем источники силы на три категории с разной математикой.

### A. Внутренняя Сила (Internal Power) -> БАЗА
Это то, кем персонаж является. Его тело, опыт, знания.
*   **Источники:** Атрибуты, Скиллы, Дары.
*   **Математика:** Сложение (`+`).

### B. Внешнее Усиление (External Power) -> МНОЖИТЕЛИ
Это то, что персонаж использует. Экипировка, магия.
*   **Источники:** Предметы, Баффы.
*   **Математика:** Умножение (`*`).

### C. Временные Эффекты (Temp Layer) -> ДИНАМИКА
Это то, что происходит прямо сейчас.
*   **Источники:** Активные абилки, дебаффы, зелья.
*   **Математика:** Любая (`+`, `-`, `*`, `=`).
*   **Особенность:** Хранится в отдельном поле `temp` и может переопределять всё.

---

## 2. Концепция: Text-Based Math Protocol
Мы отказываемся от сложной типизации модификаторов в коде. Все значения передаются как **строки-инструкции**.

*   `"15"` -> Базовое значение (Base).
*   `"+50"` -> Аддитивный бонус (Flat Add).
*   `"-10"` -> Штраф (Flat Sub).
*   `"*1.5"` -> Мультипликатор (Multiplier).
*   `"=100"` -> Жесткая установка (Override).

**Преимущество:** Zero-Transformation Pipeline. Если в БД хранить строки `"+50"`, то Ассемблер просто перекладывает JSON из БД в Redis без парсинга.

---

## 3. Алгоритм: Waterfall Calculation (Водопад)

Процесс расчета идет в три фазы, где данные "текут" сверху вниз.

**Общая формула:** `Final = Base + Sum(Sources) + Sum(Temp)`

### Логика Override (=)
Если в словаре `temp` (или `sources`) встречается значение, начинающееся с `=`, вся остальная математика игнорируется, и характеристика принимает это значение.
*   *Пример:* `Base: 10`, `Source: +5`, `Temp: =1`. Результат: `1`. (Используется для дебаффов типа "Обездвиживание").

### Фаза 1: Расчет Атрибутов (Primary Stats)
Берем блок `attributes` из `v:raw`.
*   **Вход:**
    *   Base: `10`
    *   Sources: `{"race": "+2"}`
    *   Temp: `{"buff": "+5"}`
*   **Расчет:** `10 + 2 + 5 = 17`
*   **Выход:** `final_strength = 17`

### Фаза 2: Конвертация (Derivation Bridge)
Превращаем Атрибуты в Модификаторы, используя глобальные правила (`DERIVATION_RULES`).

*   **Правило:** `1 Strength = +1.5 Physical Damage`
*   **Действие:**
    1.  Берем `final_strength` (17).
    2.  Считаем бонус: `17 * 1.5 = 25.5`.
    3.  Создаем **Виртуальный Источник**: `"+25.5"`.
    4.  Впрыскиваем его в `modifiers.physical_damage_min`.

### Фаза 3: Расчет Модификаторов (Secondary Stats)
Берем блок `modifiers` (с уже впрыснутыми бонусами от атрибутов).
*   **Вход:**
    *   `derived:strength`: `"+25.5"` (из Фазы 2) -> Это БАЗА.
    *   `skill:sword_mastery`: `"+10"` -> Это БАЗА.
    *   `item:sword`: `"*1.1"` (Внешнее усиление).
    *   `buff:rage`: `"*1.2"` (Внешнее усиление, Temp).
*   **Расчет:** `(25.5 + 10) * 1.1 * 1.2 = 46.86`
*   **Выход:** `final_damage = 46.86`

---

## 4. Optimization: Dirty Flags (Сигнальный Кэш)

Чтобы не пересчитывать все 50+ статов каждый тик, мы используем механизм `dirty_stats`.

### Логика работы
1.  **Check:** В начале обработки действия Воркер проверяет `actor.dirty_stats`.
2.  **Full Calc:** Если `actor.stats` отсутствует (первый запуск) -> Полный пересчет всех полей.
3.  **Partial Calc:** Если `actor.stats` есть, но `dirty_stats` не пуст -> Пересчитываем **только** указанные поля (и зависимые от них).
4.  **Skip:** Если `dirty_stats` пуст -> Используем существующий `actor.stats`.
5.  **Clear:** После пересчета очищаем `dirty_stats`.

### Кто ставит флаги?
*   `AbilityService`: При изменении `raw.temp` добавляет ключи в `dirty_stats`.
*   `ItemService`: При смене экипировки (если такое возможно в бою) добавляет ключи.
