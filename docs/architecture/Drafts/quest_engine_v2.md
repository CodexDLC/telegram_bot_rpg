# ⚙️ Quest Engine v2.0: Технический стандарт

Спецификация системы сценариев, основанная на JSON-конфигурациях и обработчиках в Python.

## 1. Структура Данных (Context)
В Redis сессия сценария хранится под ключом `scen:session:{char_id}:data` в следующем формате:

```json
{
  "quest_key": "awakening_rift",
  "current_node_key": "start_node",
  "w_strength": 5,
  "w_agility": 2,
  "loot_queue": ["sword_common"],
  "is_two_handed": 0
}
```

## 2. Спецификация JSON Сценария

### А. ScenarioMaster (Метаданные)
Управляет глобальными параметрами квеста и статус-баром.
*   **Поля:** `quest_key`, `start_node_id`, `status_bar_fields`.

### Б. ScenarioNode (Контент и Логика)
Описывает конкретный экран. Поддерживает типы:
*   **Обычная сцена:** Текст + кнопки с математикой.
*   **Logic Gate:** Автоматический переход на основе условий (branching).
*   **Smart Selection:** Фильтрация нод через `selection_requirements` (условия: `has_item`, `rand`, `len`).

## 3. Ядро Математики (Math Engine)
Поддерживаемые операции в `actions_logic`:
*   **Инкремент/Декремент:** `"+1"`, `"-5"`.
*   **Присваивание:** `"=10"`.
*   **Рандом:** `"1d6"`, `"2d10"`.
*   **Списки:** `"push:id"`, `"pop:id"` (очереди наград/навыков).

## 4. Жизненный цикл (Pipeline)
1.  **Initialize:** Обработчик (Handler) создает сессию, обнуляет счетчики весов.
2.  **Step:** Игрок совершает действия, `ScenarioDirector` обновляет контекст в Redis.
3.  **Finalize:** При достижении финала вызывается `on_finalize`:
    *   Сортировка весов -> Запись статов в `ac:{char_id}`.
    *   Материализация лута через `InventoryRepo`.
    *   Разблокировка навыков через `SkillProgressRepo`.