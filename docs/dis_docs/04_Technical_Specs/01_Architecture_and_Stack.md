# Техническая Архитектура и Стек

## 1. Технологический Стек (Current & Roadmap)

### Core (Backend)
* **Язык:** Python 3.11+
* **Фреймворк:** `aiogram 3.x` (Асинхронный, Long-polling).
* **Управление зависимостями:** `pip` / `requirements.txt`.

### Данные (Persistence)
* **Основная БД (Hot/Cold Data):**
    * *Alpha:* `SQLite` (`aiosqlite`). Простота, файл.
    * *Beta/Prod:* `PostgreSQL` (в Docker). Надежность, JSONB.
* **Миграции:**
    * *Alpha:* `Base.metadata.create_all()` (Создание при старте).
    * *Beta:* `Alembic` (Версионирование схемы БД).
* **Кэш и Состояния (FSM):**
    * `Redis` (Docker). Хранение FSM состояний, навигационных данных, очередей.

### AI & Generation
* **Provider:** Google Gemini API (Model: 1.5 Flash/Pro).
* **Библиотека:** `google-genai` (New SDK).

## 2. Архитектурные Решения

### Обработка Длительных Процессов (AFK)
* **Метод (MVP):** "Time Delta".
    * При старте действия (Тренировка) в БД пишется `timestamp_start`.
    * Фоновые процессы не висят в памяти.
    * При входе/завершении вычисляется `now() - timestamp_start`.
* **Roadmap:** Переход на Task Queue (`Arq` / `Celery`) для честных таймеров и пуш-уведомлений.

### Генерация Контента (AI Pipeline)
**Принцип "Первопроходца" (Caching & Reuse):**
1.  Игрок запрашивает контент (описание меча, комнаты, квеста).
2.  **Check:** Система ищет готовый вариант в БД/Кэше.
3.  **Hit:** Если есть — отдает готовое (быстро, бесплатно).
4.  **Miss:** Если нет — делает запрос к AI, сохраняет результат в БД, отдает игроку.
*Результат:* Чем дольше живет сервер, тем меньше нагрузка на AI и богаче лор.

### Боевая Система (Anti-Spam)
* **Подход:** Итеративный.
* **Start:** Базовый Throttling (aiogram middleware).
* **Plan B:** Очередь сообщений (Message Queue), если нагрузка станет критической.

## 3. Инфраструктура (DevOps)
* **Контейнеризация:** Docker + Docker Compose (App, Redis, позже DB).
* **CI/CD:** GitHub Actions (Linter `Ruff`, Type Checker `Mypy`).
* **Логирование:** `Loguru` (JSON-логи для продакшена, цветные для консоли).