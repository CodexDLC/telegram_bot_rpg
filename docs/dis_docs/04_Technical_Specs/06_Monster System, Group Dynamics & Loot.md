## 1. Концепция (High Concept)

Монстры — процедурно генерируемые сущности.

Основа — Семейство (Family) (поведение группы) и Вариант (Variant) (статы).

Монстры всегда используют Common (Tier 0) экипировку, параметры которой скалируются (умножаются) в зависимости от уровня угрозы, но не меняют материал.

---

## 2. Архитектура Данных (Data Structure)

### 2.1 Шаблон Монстра (JSON) — "Исходник"

Хранит диапазоны и варианты выбора. Все данные для Tier 0.

JSON

```
"orc_grunt": {
    "id": "orc_grunt",
    "base_tier": 0,
    "family": "orcs", 
    
    // БАЗОВЫЕ СТАТЫ (Tier 0)
    "base_stats": { "strength": 10, "agility": 6, ... },

    // ВАРИАНТЫ ЭКИПИРОВКИ (Common)
    "loadout_options": {
        "main_hand": ["rusty_sword", "club"], 
        "chest_armor": ["rags", "leather_vest"]
    },
    
    // ТЕГИ
    "narrative_tags": ["brutal", "dumb"]
}
```

### 2.2 Модель в БД (`monster_variants`) — "Кэш Вида"

Хранит **результат скалирования**. Если мы один раз посчитали "Орка Тир 2", мы сохраняем эти цифры, чтобы не считать снова.

|**Field**|**Type**|**Description**|
|---|---|---|
|`id`|UUID|Уникальный ID варианта|
|`template_id`|String|`orc_grunt`|
|`tier`|Int|2|
|`tags_hash`|String|Хэш тегов (для поиска: `md5("forest,tier2")`)|
|`scaled_stats`|JSON|`{ "strength": 15, "agility": 9 ... }` (Уже умножено)|
|`scaled_loadout`|JSON|`{ "main_hand": { "id": "rusty_sword", "damage": 8, "bonuses": {...} } }`|
|`threat_rating`|Int|Оценка силы (для балансировщика)|

---

## 3. Pipeline: Спавн и Скалирование

Процесс создания нового вида монстра (если его нет в кэше).

### Шаг 1: Выбор Loadout (Selection)

Из списка `loadout_options` случайно выбираются конкретные предметы.

- _Выбор:_ `main_hand` -> `"rusty_sword"`.
    

### Шаг 2: Скалирование (Scaling)

Применяем `TierMultiplier` к числам.

- **Stats:** `Final_STR = Base_STR (10) * Mult (1.5) = 15`.
    
- **Item:** Берем параметры `rusty_sword` из `weapons.py`.
    
    - `Damage: 5` -> `5 * 1.5 = 7.5`.
        
    - `Crit: 5%` -> `5% * 1.5 = 7.5%`.
        
    - _Примечание:_ Материал не присваивается. Это просто "Ржавый меч" с раздутыми статами.
        

### Шаг 3: Сохранение (Caching)

Записываем полученные словари `scaled_stats` и `scaled_loadout` в БД.

---

## 4. Pipeline: Бой (Runtime)

Когда начинается бой, данные из БД передаются в `CombatCalculator`.

1. **Загрузка:**
    
    - Получаем объект `MonsterVariant` из БД.
        
2. **Инициализация Бойца (`CombatMonster`):**
    
    - В этот момент `CombatCalculator` объединяет данные.
        
    - `Final Physical Damage` = `Loadout.Damage (7.5)` * (1 + `Stats.STR_Bonus`).
        
    - `Final HP` = `Stats.END` * `Formula`.
        
3. **Результат:**
    
    - Готовый к бою объект с финальными значениями.
        

---

## 5. Система Лута (Loot)

Лут генерируется при смерти.

1. **Roll:** Проверка шанса дропа (30%).
    
2. **Source:** Смотрим в `scaled_loadout` монстра.
    
    - Видим: `"rusty_sword"` (Tier 0 base).
        
3. **Generation:**
    
    - Для игрока мы генерируем **новый полноценный предмет** того же Тира, что был монстр.
        
    - `LootService` вызывает `ItemAssembler`:
        
        - `Base`: "rusty_sword"
            
        - `Tier`: 2 (Тир монстра) -> Применится материал "Iron" (или соответствующий Тиру 2).
            
    - _Логика:_ Игрок подбирает "тот самый меч", но в руках игрока он становится нормальным крафтовым предметом соответствующего уровня.
        

---

## 6. Групповая Динамика (Families)

- **Spawn Rules:** Хранятся в конфиге Семейства (`min_count`, `max_count`, `formation`).
    
- **Threat System:**
    
    - Бюджет энкаунтера набирается суммированием `threat_rating` вариантов.
        
    - Пример: Бюджет 500. Берем 1 Орка (150) + 3 Гоблинов (по 100) + 1 Волка (50).
        

---

### План реализации (Next Steps)

1. **DB:** Создать таблицу `monster_variants`.
    
2. **Service:** Реализовать `MonsterScalingService` (только математика, без ассамблера).
    
3. **Calculator:** Убедиться, что он умеет принимать "готовые" статы монстра, а не рассчитывать их с нуля как для игрока (у игрока статы зависят от надетых предметов, у монстра статы — это база).