# Стандарт реализации Хендлеров и UI (V2)

## 1. Введение
Этот документ описывает стандарт взаимодействия между слоями `Handler`, `Orchestrator` и `UI Service` в проекте Telegram Bot RPG.
Цель стандарта — унифицировать обработку запросов, разделить ответственность и упростить поддержку кода.

## 2. Архитектурные слои

### 2.1. Handler (Контроллер)
*   **Ответственность**: Прием входящих событий (Message, CallbackQuery), извлечение параметров, вызов Оркестратора и отправка ответа через `ViewSender`.
*   **Запрещено**: Содержать бизнес-логику, формировать тексты/клавиатуры, напрямую вызывать Core API.

### 2.2. Orchestrator (Фасад)
*   **Ответственность**: Координация процесса. Получает запрос от Хендлера, вызывает методы Core Client (бизнес-логика), получает DTO результата и передает его в UI Service для рендеринга.
*   **Наследование**: Все UI-оркестраторы наследуются от `BaseBotOrchestrator`.
*   **Метод `render`**: Обязательный метод, принимающий `payload` и возвращающий `UnifiedViewDTO`. Работает как чистая функция.
*   **Метод `process_response`**: Обрабатывает ответ от ядра, проверяет смену стейта (через Header) и делегирует управление `GameDirector` при необходимости.

### 2.3. UI Service (Представление)
*   **Ответственность**: Преобразование DTO данных в `ViewResultDTO` (текст + клавиатура).
*   **Запрещено**: Делать запросы в БД или API. Только форматирование.

### 2.4. ViewSender (Доставка)
*   **Ответственность**: Умная отправка сообщений (Edit vs Send New), управление `message_id` в FSM.

## 3. Роли сообщений и UnifiedViewDTO
Интерфейс игрока строится на концепции **Dual-Message System**, где экраны разделены на "Статичный контекст" и "Активную зону".

### Menu (Верхнее сообщение): «Статус и Навигация / Лог»
*   **Роль**: Отображает глобальные данные, которые должны быть всегда перед глазами.
*   **В мирном режиме**: Показывает BIO персонажа (Имя, Класс, Уровень), полоски HP/Energy и кнопки переключения глобальных режимов (Инвентарь, Карта, Профиль).
*   **Источник данных**: Преимущественно «горячий кэш» ядра (`ac:{char_id}`), чтобы не делать тяжелых запросов.
*   **В бою**: Это сообщение превращается в Лог Боя (список последних событий). В будущем здесь будут кнопки настройки боя.
*   **Позиция**: Отправляется первым (висит сверху).

### Content (Нижнее сообщение): «Рабочая область»
*   **Роль**: Динамическая часть интерфейса. Показывает то, что происходит прямо сейчас.
*   **Содержание**: Текст текущей сцены, описание выбранного предмета, портрет врага.
*   **Управление**: Содержит кнопки действий внутри текущего состояния (Атаковать, Сделать шаг, Использовать предмет, Выбрать реплику).
*   **Позиция**: Отправляется вторым (находится внизу, ближе к полю ввода).

### UnifiedViewDTO
Это единственный объект, который Оркестратор возвращает Хендлеру.
*   `menu`: Данные для верхнего сообщения (Статус/Лог).
*   `content`: Данные для нижнего сообщения (Сцена/Действия).
*   `alert_text`: Текст для мгновенной обратной связи (Toast/Alert).
*   `clean_history`: Флаг полной перерисовки.

## 4. Правила рендеринга (ViewSender)
Мы отказываемся от ручного управления `message_id` в хендлерах. Вся логика доставки инкапсулирована в `ViewSender`.

*   **ViewSender**: Эфемерный сервис.
*   **Наследование**: Наследуется от `BaseUIService`.
*   **Логика**: Знает, что `message_menu` — это верхнее, а `message_content` — нижнее. Сам решает: редактировать старое сообщение или удалять и слать новое (например, если "нижнее" сообщение убежало слишком далеко вверх из-за лога).
*   **Запрет на ручной edit**: Хендлеры не должны вызывать `bot.edit_message_text`.
*   **Flow**: `Orchestrator` -> `UnifiedViewDTO` -> `ViewSender.send()`.

## 5. Пример реализации (Combat)

```python
# Handler
async def combat_attack(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
    # ... init dependencies ...
    orchestrator = container.get_combat_bot_orchestrator(session)
    
    # Action
    view = await orchestrator.handle_attack(char_id, target_id)
    
    # Render
    sender = ViewSender(bot, state, await state.get_data(), callback.from_user.id)
    await sender.send(view)
    await callback.answer(view.alert_text)
```
