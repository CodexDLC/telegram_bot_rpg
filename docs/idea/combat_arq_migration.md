# Миграция боевой системы (RBC) на ARQ (Task Queue)

## Текущая архитектура (Stateful Supervisor)
На данный момент используется `CombatSupervisor` — долгоживущая `asyncio.Task`, которая запускается для каждой боевой сессии.
- **Плюсы**: Простота, низкая латентность (нет поллинга очереди).
- **Минусы**: Сложно масштабировать (stateful), потребление памяти (тысячи тасков), риск потери управления при рестарте.

## Целевая архитектура (Stateless Workers + ARQ)
Переход на событийную модель (Event-Driven), где каждое действие порождает задачу для пула воркеров.

### Основные компоненты

1.  **TurnManager (Producer)**
    *   При получении хода (`register_move`) не запускает Supervisor.
    *   Вместо этого ставит задачу в очередь ARQ:
        *   `check_session_task(session_id)` — мгновенная проверка на наличие пары.
        *   `timeout_task(session_id)` — отложенная задача (`_defer_until`) на время дедлайна (страховка от AFK).

2.  **ARQ Worker (Consumer)**
    *   Пул воркеров (например, 10-50 процессов/корутин), читающих очередь Redis.
    *   Обрабатывает задачи `check_session_task` и `timeout_task`.

### Алгоритм обработки

#### Сценарий 1: Нормальный обмен ударами
1.  **Игрок А** делает ход.
    *   TurnManager пишет пулю в Redis.
    *   TurnManager ставит `check_session_task(sid)`.
    *   TurnManager ставит `timeout_task(sid, defer=60s)`.
2.  **Воркер** берет `check_session_task`.
    *   Берет **Redis Lock** (`lock:combat:{sid}`).
    *   Проверяет наличие пары пуль. Пары нет (только А).
    *   Снимает Lock, завершает задачу.
3.  **Игрок Б** делает ход (через 5 сек).
    *   TurnManager пишет пулю.
    *   TurnManager ставит `check_session_task(sid)`.
4.  **Воркер** берет `check_session_task`.
    *   Берет Lock.
    *   Видит пару пуль (А и Б).
    *   Вызывает `CombatService.process_exchange()`.
    *   Очищает пули.
    *   Снимает Lock.
5.  **Воркер** (через 55 сек) берет `timeout_task`.
    *   Проверяет состояние. Пули А уже нет (раунд прошел).
    *   Завершает задачу (No Op).

#### Сценарий 2: AFK (Таймаут)
1.  **Игрок А** делает ход.
    *   Пуля записана.
    *   `timeout_task` запланирован на T+60s.
2.  **Игрок Б** спит.
3.  **Воркер** (через 60 сек) берет `timeout_task`.
    *   Берет Lock.
    *   Видит, что пуля А все еще лежит, а пули Б нет.
    *   Понимает, что Б — AFK.
    *   Генерирует рандомный ход за Б.
    *   Вызывает `CombatService.process_exchange()`.
    *   Увеличивает счетчик AFK Penalty для Б.
    *   Снимает Lock.

### Необходимые изменения

1.  **Инфраструктура**:
    *   Подключить библиотеку `arq`.
    *   Настроить `WorkerSettings` (Redis connection, functions).
    *   Запустить процесс воркера (`arq apps.worker.Settings`).

2.  **CombatTurnManager**:
    *   Заменить `_ensure_supervisor` на `arq.enqueue_job`.

3.  **CombatService**:
    *   Адаптировать под запуск из воркера (DI контейнер внутри воркера).

4.  **Redis Locking**:
    *   Реализовать надежный механизм блокировки сессии на время расчета раунда (чтобы `check_session` и `timeout` не подрались).

### Преимущества
*   **Масштабируемость**: Можно запустить хоть 100 воркеров на разных машинах.
*   **Надежность**: Если воркер падает, задача переназначается.
*   **Ресурсы**: Нет простоя памяти на ожидание (asyncio.sleep). Память тратится только в момент расчета.
